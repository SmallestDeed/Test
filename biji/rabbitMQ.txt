rabbitMQ可靠性

为什么很少用redis？

什么是耦合？相互依赖

为什么使用消息队列？
1.实现异步：批量数据的异步处理
2.解耦：串行任务的并行化
3.削峰：高负载任务的负载均衡。先进先出
解决：异步通信

实现AMQP协议
工作模型
Borker：
TCP长连接
虚拟连接：消息信道
channel
Queue：队列，存储消息，独立运行的进程，拥有自己的数据库
交换机：地址列表，绑定队列
virtual host：虚拟机，资源隔离，提高硬件利用率；为了解决消息的灵活的路由

1.直连交换机和队列绑定的时候必须指定精确的binding key
routing key 路由关键字
channel.basicPublish("交换机类型","binding key","消息")
一对一

2.Topic Exchange:主题类型交换机
binding key
#表示0个或多个单词
*表示一个单词

3.广播交换机：Fanout Exchange


确保数据安全
1.事务模式
2.确认模式
1）.普通每条都确认
2）.批量确认
3）.异步随机确认

路由保证
1.发给自己
2.发给备份交换机

消息存储
1.队列持久化
2.交换机持久化
3.消息持久化

autoAck：消费者刚接收到消息就发送
手动应答：channel.basicAck，放在finally里面

生产者怎么知道消费者有没有正确消费消息？
1.生产者发送消息，提供接口回调的api，消费者接收到消息之后调用api
2.消费者接收到消息之后，发送一个mq给生产者

消息幂等性
重发：控制次数--计数器
对账
流水号  唯一
重账控制