熟悉的领域（一定搞一个熟悉的技术，长处。。。es，redis）


------------------------------------
多线程的作用？
1.提升响应性能
2.提高cup利用率
。。。。
--------------------------------------------
多线程引起的问题？
1.线程安全问题---多个线程对共享资源进行操作的问题
2.原子性问题
3.可见性问题

共享资源？？？-----被所有线程能共同访问到的资源
--------------------------------------------
volatile可以解决可见性问题
多了lock指令-----作用
1.把当前处理器缓存行的数据写回到系统内存
2.写回内存的操作会使其他cpu里缓存了该内存的地址数据无效
其他cpu（多核cpu）
处理器缓存行---cpu高速缓存
---最终就是系统内存中的数据都是最新的数据
--------------------------------------------
synchronized解决原子性问题
但是带来了性能问题？怎么解决
1.控制锁的粒度（对象锁和类锁）
2.锁本身的优化

锁性能优化：在性能和安全性中间取一个平衡
锁性能开销：
无锁>偏向锁>轻量级锁>重量级锁
-------------------------------------------
cas机制
compare and swap，比较并替换，原理是有三个核心组件：
1.内存地址（表示内存中变量的动态的值）
2.旧的预期值（自我理解就是内存变量值在某一刻的快照）
3.新值（就是变量计算后的新的值）
每次去拿内存地址和旧的值做比较，如果相同则把内存值改为新值，如果不同则重新获取内存值和旧的预期值，并计算新的新值，再次比较，每次重新获取新值的过程称为自旋，（利用了volatile使数据保持可见性）

java中使用的地方：原子操作类（atomic包下的类），lock系列类的底层实现。。。。了解下lock系列类

与synchronized的比较：cas乐观的认为程序中的并发不是很严重（乐观锁），同步锁悲观的认为程序中的并发很严重（悲观锁）
synchronized会让没有锁资源的线程进入阻塞状态，而后在争夺到资源之后恢复到runnable状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高（java 1.6中对synchroniezd的做了优化，增加了偏向锁-->轻量级锁-->重量级锁的过渡，在重量级锁之前也会使用cas机制）

缺点：
1.cpu开销比较大，在高并发的情况下，很消耗cpu性能
2.不能保证代码块的原子性，只能保证单个变量的原子性
3.aba问题，有事务回滚的情况下会出现严重的数据错误

-----------------------------------------------------------
hsdis查看java程序运行的汇编指令

有缓存就会带来缓存一致性问题
